from gathernews.gRSS import CaptureFeeds
import sqlite3

# This should handle anything related to input/output for a
# sqlite3 database


class SQLite3Read:
    """ Anything related to SQLite3 IO """

    def __init__(self, path):
        self.path = path
        self.capture_feeds = CaptureFeeds(self.path)

    

    def transaction_query(self):
        """ Snagged this from gRSS, not at all working """
        ## Create transaction query for SQL database
        try:
            insert_query_table_name = re.sub(r'\W+', '',\
                                             the_articles.feed.title)
        except:
            insert_query_table_name = "table_name_not_found"
            
            if self.match_names(insert_query_table_name) == True:
                insert_query = "INSERT INTO " + insert_query_table_name + \
                               " VALUES (?,?,?,?,?)"
                
                # unicode to ascii so life can go on.......
                insert_query = insert_query.encode('ascii')
                
                # Populate data structure
                insert_this_data[insert_query] = data_hold 
                

     def make_table_names(self, RSS_link, create_these_tables):
        """ Make the table names for the sqlite3 database.

        Args:
            RSS_link: RSS_link from 'feeds_list.txt'
            create_these_tables: A list of table names to be created.

        Returns:
            The 'create_these_tables' list is returned with a table name
            appended to it.
        """
        


    def create_these_tables(self, current_feeds_list, previous_feeds_list):
        """ Table names for new tables are generated.

        Args:
            current_feeds_list: List of RSS_links inputted by the user.
            previous_feeds_list: List of RSS_links generated by the program
                                 to keep track of tables currently in the
                                 database.
        
        Returns:
            A list of table names for tables that do not currently
            exist in the databases are created.
        
        Raises:
            UserWarning: RSS links have not been added to 'feeds_list.txt'
            UserWarning: Blank entry found, can't make table_name

        """
        # This method should be in sqlite3_io or mongo_io. 
        




        
        # First, we need to know that the RSS links have been properly added.
        #if len(current_feeds_list) == 0:
        #    raise UserWarning("RSS links have not been added to"\
         #                     + " 'feeds_list.txt'")

        # Second, we can now generate a list of table names. 
        #create_these_tables = []
        #for RSS_link in current_feeds_list:
            # If there is nothing in previous_feeds_list then append names.
        #    if previous_feeds_list == False:
         #       self.make_table_names(RSS_link, create_these_tables)

            # If previous_feeds_list is not empty check RSS links against
            # previously used RSS links.
         #   elif RSS_link not in previous_feeds_list:
          #      self.make_table_names(RSS_link, create_these_tables)
            # When no new tables need to be added return False
           # else:
           #     pass

        # create no tables if they aren't needed
        #if len(create_these_tables) == 0:
        #    return False
       # else:
        #    return create_these_tables


    def do_tables_exist(self): 
        """ Checks to see if new tables should be created

        The real job of this is to probably set & reset
        previous_feeds_list.json which we haven't done yet. 

        Returns:
            A list of table names for tables that have not been created.
        """
        # We should read the relations table in the sqlite3 db for this method
        # this method belongs in sqlite3_io
        #
        # no more random json kicking around. 

    def match_names(self, query_name):
        """ Match SQL database table names to table names used for insert
        query """
        # This should also be in the sqlite3_io module. Here we're querying
        # the relations table.
        

    def get_tablenames(self):
        """ All table names are extracted for use in SQL queries.

        Returns:
            revised_list: A list of all table names in the database is here.
        """
        # Init db locally 
        conn = sqlite3.connect(self.path + "FeedMe.db")
        c = conn.cursor()
        # List of tables to query
        c.execute("SELECT name FROM sqlite_master WHERE type='table';")
        # List of tables names that can be queried
        list_tables = c.fetchall()
        # Create a revised list for insert query
        revised_list = [str(list_tables[t_name]).strip('(')\
                        .strip(')').strip(',').strip('u').strip("'") 
                        for t_name in range(len(list_tables))]
        conn.close() # close sqlite3 db
        return revised_list

    def create_tables(self):
        """ Creates tables for RSS news feeds

        Creates db tables where each RSS link feeds
        into a separate table because it's easier
        to aggregate then deaggregate.
        """
        tables = self.capture_feeds.do_tables_exist()
        if tables:
            # Open database locally
            conn = sqlite3.connect(self.path + "FeedMe.db")
            conn.isolation_level = None
            c = conn.cursor()
            transaction_query = "BEGIN; "
            for table_name in tables:
                table = "CREATE TABLE " +  table_name + \
                        "( primary_key text, title text," + \
                        " description text, link text, published text); "
                transaction_query = transaction_query + table
                # Which tables are being entered?
                print "\t" + table_name
                
            transaction_query = transaction_query + " COMMIT;" 
            # Create table in sqlite3
            c.executescript(transaction_query)
            # close sqlite3 db
            conn.close()
            return True
        elif tables is False:
            print("\n\tNo new tables need to be created")
            return False
        else:
            raise UserWarning("do_tables_exist() not returning a value")

        
    def populate_db(self):
        ''' 
        Queries are matched with dict keys which then
        provides the values associated with each query by sharing
        the table names as a reference point. This allows rows to be 
        populated for each table leading to the population of the db.
        '''
        # Set up connection
        conn = sqlite3.connect(self.path + "FeedMe.db")
        c = conn.cursor()
        # Execute SQL script
        data = self.rss_feeds_data()
        for table in data.keys():
            c.executemany(table, data[table])
        conn.commit()
        # close sqlite3 db
        conn.close() 
        print("\tpopulate_db is complete")


    def rm_duplicates(self):
        '''
        Limitation of this duplicate removal approach is that only one
        duplicate entry will be removed (containing the lowest valued
        primary_key). If the number of  duplicate entries per item  > 2
        then that will introduce a bug. 
        '''
        # Set up connection
        conn = sqlite3.connect(self.path + "FeedMe.db")
        c = conn.cursor()
        # Remove duplicate queries
        dup_script = "BEGIN TRANSACTION; "
        for table_name in self.get_tablenames():
            query = "DELETE FROM " + table_name + " WHERE primary_key " \
                    "NOT IN " \
                    "(SELECT min(primary_key) FROM " + table_name + \
                    " GROUP BY title, published); "
            dup_script = dup_script + query
        dup_script = dup_script + "COMMIT TRANSACTION;"
        c.executescript(dup_script)
        conn.close()
        print("\trm_duplicates is complete")


    
class SQLite3Write:
    pass
